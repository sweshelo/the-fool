# 効果テキスト実装ガイド

効果テキスト実装は、以下のルールを守る必要があります。

## ファイル名

ファイル名は、`catalog.jsonに登録されているカードID.ts` である必要があります。

## 関数名とその型

`effects/classes/types.ts` を参照。

イベント名の代表的なものを挙げる。

| 識別子       | 内容                           | 例             |
| ------------ | ------------------------------ | -------------- |
| drive        | 召喚された                     | onDrive        |
| break        | 破壊された                     | onBreak        |
| bounce       | 手札に戻す効果が発動した       | onBounce       |
| damage       | ダメージを与える効果が発動した | onDamage       |
| turnStart    | ターン開始                     | onTurnStart    |
| overclock    | オーバークロックした           | onOverclock    |
| playerAttack | プレイヤーアタックに成功した   | onPlayerAttack |

関数名には、以下の Suffix が有効。

| 識別子  | 用途                                       | 例                 |
| ------- | ------------------------------------------ | ------------------ |
| Self    | 自分自身がイベントの対象である場合         | onDriveSelf        |
| InTrash | 対象のイベント発生時に自身が捨札にある場合 | onTurnStartInTrash |

関数の引数の `Stack` に含まれる値はそれぞれ次の意味を持つ。

| キー名     | 内容   | 用途                                                                                                                                                                                                                 |
| ---------- | ------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| processing | 自身   | 発動したカード自身のLvを参照したり、発動したユニット自身に対する操作を行う際に用いる                                                                                                                                 |
| source     | 発生源 | イベントの発生元を指す。召喚であれば召喚したプレイヤー、アタックであればアタックを宣言したプレイヤー、戦闘であればアタッカーが当てはまる。プレイヤーの操作が介在するイベントにおいては、概ねプレイヤーが指定される。 |
| target     | 対象   | イベントの対象を指す。召喚であれば召喚されたユニット、アタックであればアタックするユニット、戦闘であればブロッカーが当てはまる。                                                                                     |

## 効果実装ガイド

### カードの型

`src/submodule/suit/types/game/card/index.ts`を参照。実装は`src/package/core/class/card/*.ts`を参照。

### 共通ガイドライン

- 発動タイミングについて言及されていないキーワード効果(【】で括られた能力)がテキストにある時、それは召喚時に付与されることを示している。onDriveSelfの処理に追加すること。
- カードの移動は Effect.move を、BPの操作は Effect.modifyBP を使い、各オブジェクトの値を直接操作してはならない。
- 「ブロックされない」効果は、 Effect.keyword() で '次元干渉' を付与し、そのコストに0を指定する。
- ユニットを選ぶ効果は `EffectHelper.selectUnit()` を利用するが、この引数に渡す選択肢は予め `EffectHelper.candidate()` で選択可能であるかを検証しておかなければならない。
- カードを選ぶ効果は `EffectHelper.selectCard()`を利用する。 selectUnit() と selectCard() の違いは、その選択対象がフィールドいるかいないかである。フィールド上のユニットを選ぶ場合は前者を、そうでない場合は後者を利用せよ。
- エラーハンドリングはフレームワーク側が実施するので、例外を投げる可能性のある関数を呼び出す場合でも try-catch は必ずしも必要ではない。

### 通常関数

通常関数とは、効果が発動した際に呼び出される関数のことを指す。通常関数では、どのような効果を発動したかを表示する `System.show()` メソッドを呼ばなくてはならない。

**この `System.show()` メソッドを呼び出す際には、効果の発動に必要な条件を全て満たしており、間違いなく効果を最後まで発動し切る事ができる状況であることが担保されていなくてはならない。また、このメソッドは1効果中に1度しか原則呼び出してはならない。**

例えば、相手のユニットを1体選んで破壊する、という効果の実装にあたっては、相手のフィールドにユニットがいること、相手のユニットのフィールドを1体以上選択できること(EffectHelper.candidate()を用いて確認する)を検証しなければならない。

つまり、通常効果関数においては、型ガード的意味合いを持つものを除き、if文は1箇所だけであることが望ましい。

### 永続関数

永続関数とは、 `handEffect()` と `fieldEffect()` のことを指す。

**このメソッドは、規定のタイミングで何度も呼び出される。この時、カードのテキスト内容を逸脱して効果が重複するような実装をしてはならない。(冪等に近い実装が求められる)**

具体的には、変化を与える対象に `Delta` を発行する実装を採用する。

```ts
// ダメな例: 自身のBPを+1000する
fieldEffect(stack){
  stack.processing.bp += 1000; // fieldEffect()が呼び出されるたびにBPが1000ずつ増えていく (fieldEffectがいつ何回呼ばれるかは解決されるStackの深さにも依存するため不定である)
}

// 良い例: 自身のBPを+1000する
fieldEffect(stack){
  // 既にこのユニットが発行したDeltaが存在するか確認する
  const delta = stack.processing.delta.find(delta => delta.source.unit === stack.processing.id);
  if(delta && delta.effect.type === 'bp'){
    // Deltaを編集する
    delta.effect.diff = 1000;
  } else {
    // 関数を通じてDeltaを生成する
    // source: unit に効果の発動元を格納することで、発動元に【沈黙】が付与されて効果が無効化された時や、ユニットがフィールドから離れた際、core側で自動的にdeltaの除去が実行されます。
    Effect.modifyBP(stack, stack.processing, stack.processing, diff, { source: { unit: stack.processing.id } })
  }
}

// 例: 自身がLv1の時に【秩序の盾】を与える
fieldEffect(stack){
  // 既にこのユニットが発行したDeltaが存在するか確認する
  // NOTE: fieldEffectで複数種類の効果Deltaを提供する場合、effectCodeに識別用の値を与える
  const delta = stack.processing.delta.find(delta => delta.source.unit === stack.processing.id && delta.source.effectCode === 'Lv1_秩序の盾');

  // NOTE: Lv1の時に【秩序の盾】を与える = Lv1以外では自身が与えた【秩序の盾】を除外する効果の実装が必要

  if(delta){
    if(stack.processing.lv !== 1) {
      // ... 自身が与えた【秩序の盾】以外の Delta のみを自身にフィルタして反映する
    }
  } else {
    if(stack.processing.lv === 1){
      // ... Effect.keyword() を source オブジェクト付きで呼び出す
    }
  }
}
```

### 判定関数

判定関数は、以下の条件において、指定の名前で実装が必須である。

| 関数名     | 必要なカード                           | 返却値                                                                                                                                                                    |
| ---------- | -------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| isBootable | 起動効果 `onBootSelf` を実装した       | 起動効果を発動する条件を満たしているか、booleanを返す。                                                                                                                   |
| checkXXX   | インターセプトまたはトリガーを実装した | アクション「XXX」に対する onXXX メソッドについて、カードの効果を発動する条件を満たしているか、booleanを返す。(コストを満たしているかのチェックはシステム側で実施される。) |

## 効果を構築するためのクラス

### Effect

`effects/classes/effect.ts` にあるこのクラスは、実際にゲーム特有の「破壊」「手札に戻す」「特殊召喚」などの操作を備えている。

### EffectHelper

`effects/classes/helper.ts` にあるこのクラスは、ランダマイズ、選択可能なユニットのフィルタリング、ユニットの選択などのユーティリティを提供する。

### EffectTemplate

`effects/classes/templates.ts` にあるこのクラスは、このゲームにおいて頻出の効果を関数化して纏めたものである。

### System

`effects/classes/system.ts` にあるこのクラスは、`Effect.show` を除いてはラッパーが用意されているため、あまり利用する必要がないが、 `Effect.prompt`は〈選略〉効果を実装する際に必要になる。

#### 選略・選告

「選略」及び「選告」は、プレイヤーに2つに1つの選択肢を提示して、そのどちらかを発動する効果。選択肢のうち、どちらか一方しか選択できない状況では、選択肢の提示は行われず発動可能であるほうが自動で発動する。コードは以下のようになる。

```ts
// プロンプトを表示して効果を選択
// 選略[1]は、相手にLv3以上のユニットが存在しないと発動できない
if (opponentUnits.length > 0) {
  const [choice] =
    opponentUnits.filter(unit => unit.lv >= 3).length > 0
      ? await System.prompt(stack, stack.processing.owner.id, {
          title: '選略・空間を統べる覇者',
          type: 'option',
          items: [
            { id: '1', description: '敵全体のレベル3以上のユニットを破壊' },
            { id: '2', description: '敵全体に【沈黙】を与える' },
          ],
        })
      : ['2'];
}
```

`System.prompt` の第2引数には、その選択肢を選ぶプレイヤーのIDを指定する。「選略」では `stack.processing.owner.id` に、「選告」では `stack.processing.owner.opponent.id`を指定する。
選択肢を提示した時点で、どちらかの効果が発動することが確定する。**選択肢を提示したあとに、if文による条件分岐を行って効果を取り止めたりしてはならない。**

## テキスト

`System.show()` の第3引数は、効果のテキストを完結に纏める。この時、表示するテキストに句読点は含めない。複数の効果を発動する場合、それらを `\n` で連結する。
「このユニット」は「自身」というワードに置き換えられる。「対戦相手のユニットを1体選ぶ」といった情報は、多くの場合完全に省略される。

例えば、次のテキストであれば、

```text
このユニットがフィールドに出た時、あなたのフィールドにユニットが4体以下の場合、あなたの捨札にある進化ユニット以外のコスト7以下の青属性のユニットを1体選ぶ。それをあなたのフィールドに【特殊召喚】し、レベルを+2する。
```

以下のようになる。

```text
捨札から【特殊召喚】\nレベル+2
```

## 特殊な効果とHistory

効果の中には、ターン中の行動に依存するものがある。〈連撃〉などがそれにあたる。

```text
このユニットがフィールドに出た時、このターンにあなたがこのユニット以外のコスト2以上の緑属性のカードを使用している場合、対戦相手のユニットを1体選ぶ。それの基本BPを-5000する。
```

このような効果は、`stack.core.histories` を参照する。historyには次のようなオブジェクトがターン毎に格納される。

```ts
interface History {
  card: Card;
  action: 'drive' | 'boot';
}
```

`stack.core.histories.some(history => history.card.catalog.color === Color.GREEN && history.card.catalog.cost >= 2)` というような具合に条件を構築し、判定する。
